#!/usr/bin/env python3
# -*- mode: python; coding: utf-8 -*-
# By HarJIT in 2023, 2024.

# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at https://mozilla.org/MPL/2.0/.

import math, itertools

# 256 sample CMYK colours (4×4×4×4 cube, actually a 4×4×4×5 where the k="4" has been removed) which
#   I converted to RGB elsewhere (i.e. with software that makes use of colour profiles) and rounded
#   to 4bpc (i.e. 16×16×16 or 12-bit) RGB.  For our purposes, tetralinear interpolation of this will
#   give adequate results, and vastly better than the naïve R = 255 - K - (C * (255 - K) / 255) etc,
#   although still notably worse than using a colour profile.
_cmyk_to_rgb = [
    0xFFF, 0xCCC, 0x999, 0x666, 0xFFB, 0xCC9, 0x997, 0x664, 
    0xFE7, 0xCB6, 0x984, 0x662, 0xFE0, 0xCB0, 0x980, 0x660, 
    0xFBD, 0xB9A, 0x867, 0x645, 0xFB9, 0xC97, 0x966, 0x643, 
    0xFB6, 0xC85, 0x963, 0x642, 0xFA1, 0xC81, 0x960, 0x640, 
    0xE7A, 0xB68, 0x846, 0x624, 0xE78, 0xB66, 0x844, 0x623, 
    0xE75, 0xB54, 0x843, 0x621, 0xE72, 0xB51, 0x840, 0x620, 
    0xE08, 0xB07, 0x805, 0x603, 0xE16, 0xB05, 0x803, 0x602, 
    0xE14, 0xB13, 0x802, 0x601, 0xE22, 0xB11, 0x800, 0x500, 
    0x9DF, 0x8AC, 0x689, 0x356, 0xADB, 0x8A9, 0x687, 0x454, 
    0xAD7, 0x8A6, 0x674, 0x453, 0xBC3, 0x8A2, 0x671, 0x450, 
    0xAAC, 0x88A, 0x667, 0x445, 0xAA9, 0x887, 0x666, 0x444, 
    0xB96, 0x875, 0x664, 0x442, 0xB93, 0x872, 0x651, 0x440, 
    0xA6A, 0x858, 0x646, 0x424, 0xA68, 0x856, 0x645, 0x423, 
    0xA66, 0x854, 0x643, 0x421, 0xB63, 0x852, 0x641, 0x420, 
    0xA28, 0x817, 0x605, 0x403, 0xA26, 0x815, 0x604, 0x402, 
    0xA25, 0x824, 0x602, 0x401, 0xA23, 0x822, 0x611, 0x400, 
    0x1BE, 0x19B, 0x079, 0x056, 0x4BB, 0x399, 0x177, 0x044, 
    0x5B8, 0x496, 0x274, 0x043, 0x5B4, 0x493, 0x372, 0x141, 
    0x59C, 0x47A, 0x357, 0x135, 0x699, 0x477, 0x356, 0x134, 
    0x687, 0x575, 0x354, 0x232, 0x684, 0x573, 0x352, 0x230, 
    0x66A, 0x558, 0x436, 0x224, 0x768, 0x556, 0x435, 0x223, 
    0x766, 0x554, 0x433, 0x222, 0x764, 0x553, 0x432, 0x220, 
    0x738, 0x517, 0x405, 0x203, 0x737, 0x625, 0x404, 0x202, 
    0x735, 0x624, 0x413, 0x201, 0x733, 0x622, 0x411, 0x200, 
    0x0AE, 0x08B, 0x068, 0x046, 0x0AB, 0x089, 0x066, 0x044, 
    0x0A8, 0x086, 0x065, 0x043, 0x0A5, 0x084, 0x063, 0x041, 
    0x08C, 0x06A, 0x057, 0x035, 0x089, 0x067, 0x056, 0x034, 
    0x087, 0x065, 0x054, 0x032, 0x084, 0x063, 0x042, 0x031, 
    0x06A, 0x048, 0x036, 0x014, 0x068, 0x046, 0x035, 0x013, 
    0x066, 0x045, 0x033, 0x022, 0x164, 0x143, 0x032, 0x020, 
    0x339, 0x227, 0x105, 0x003, 0x337, 0x225, 0x114, 0x002, 
    0x335, 0x224, 0x113, 0x001, 0x333, 0x222, 0x111, 0x000,
]

def _split(fourbpc):
    r = (fourbpc >> 8) * 17
    g = ((fourbpc >> 4) & 0xF) * 17
    b = (fourbpc & 0xF) * 17
    return r, g, b

def cmyk_to_rgb(c, m, y, k):
    # Unhelpfully, ITU T.416 (which ECMA-48 reserves the colourspace SGRs for) doesn't specify what
    #   the colourspace coördinates are *out of*, only that they are integers. In practice, RGB
    #   coördinates are interpreted by terminal emulators as out of 255. As for CMYK coördinates,
    #   they are generally unsupported and ignored by terminal emulators, but convention seems to
    #   be for CMYK coördinates to be out of 100, including in contexts where RGB coördinates are
    #   out of 255, see e.g. https://content.tfl.gov.uk/tfl-colour-standard-issue-08.pdf
    # Note that at least one existing implementation is documented as using the otherwise-undefined
    #   "colourspace ID" parameter to set the maximum channel value:
    #     https://github.com/mintty/mintty/wiki/Tips#text-attributes-and-rendering
    cf, mf, yf, kf = [i / 100.0 for i in (c, m, y, k)]
    cmid, mmid, ymid = [i * 3 for i in (cf, mf, yf)]
    kmid = kf * 4
    cmax, mmax, ymax, kmax = [math.ceil(i) for i in (cmid, mmid, ymid, kmid)]
    cmin, mmin, ymin, kmin = [math.floor(i) for i in (cmid, mmid, ymid, kmid)]
    quartets = [*itertools.product({cmax, cmin}, {mmax, mmin}, {ymax, ymin}, {kmax, kmin})]
    values = [_split(0x000 if k == 4 else _cmyk_to_rgb[c*64 + m*16 + y*4 + k]) for c, m, y, k in quartets]
    lookup = dict(zip(quartets, values))
    pending = lookup.copy()
    for mx, mn, md in ((kmax, kmin, kmid), (ymax, ymin, ymid), (mmax, mmin, mmid), (cmax, cmin, cmid)):
        linear_coef = (md - mn) / (mx - mn) if mx != mn else 0
        next_pending = {}
        rest_keys = {i[:-1] for i in pending.keys()}
        for rest_key in rest_keys:
            vals_for_min = pending[rest_key + (mn,)]
            vals_for_max = pending[rest_key + (mx,)]
            vals = []
            for val_for_min, val_for_max in zip(vals_for_min, vals_for_max):
                vals.append(val_for_min + linear_coef * (val_for_max - val_for_min) if val_for_min != val_for_max else val_for_min)
            next_pending[rest_key] = tuple(vals)
        pending = next_pending
    assert len(pending) == 1
    return next(tuple(map(round, i)) for i in pending.values())


